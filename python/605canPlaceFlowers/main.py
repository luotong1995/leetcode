'''
假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false 。

示例 1：

输入：flowerbed = [1,0,0,0,1], n = 1
输出：true
示例 2：

输入：flowerbed = [1,0,0,0,1], n = 2
输出：false

[1] 1/1

[1,0] 2/1


[1,0,1] 3/2
[0,1,0] 1

[1,0,1,0] 4/2
[0,1,0,1] 2


[1,0,1,0,1] 5/3
[0,1,0,0,1] 2

[1,0,1,0,1,0] 6/3
[0,1,0,1,0,1] 3
[1,0,0,1,0,1] 3
[1,0,1,0,0,1] 3
[0,1,0,0,1,0] 2

[1,0,1,0,1,0,1] 7/4
[0,1,0,0,1,0,1] 3
[1,0,1,0,0,1,0] 3

[1,0,1,0,1,0,1,0] 8/4
[1,0,1,0,0,1,0,1] 4
[0,1,0,1,0,1,0,0] 4
[0,1,0,0,1,0,1,0] 3
[0,1,0,0,1,0,0,1] 3

[1,0,1,0,1,0,1,0,1] 9/5
[1,0,0,1,0,0,1,0,1] 4
[0,1,0,0,1,0,0,1,0] 3

[1,0,1,0,1,0,1,0,1,0] 10/5
[0,1,0,0,1,0,0,1,0,1] 4

[1,0,1,0,1,0,1,0,1,0,1] 11/6
[0,1,0,0,1,0,0,1,0,0,1] 4

[1,0,1,0,1,0,1,0,1,0,1,0] 12/6
[0,1,0,0,1,0,0,1,0,0,1,0] 4
[0,1,0,1,0,0,0,1,0,0,1,0]

max

min

(2-1)/3=0,1: 0+1
(3-1)/3=0,2: 0+1
(4-1)/3=1,0: 1+1
(5-1)/3=1,1: 1+1
(6-1)/3=1,2: 1+1
(7-1)/3=2,0: 2+1
(8-1)/3=2,1: 2+1
(9-1)/3=2,2: 2+1
(10-1)/3=3,0: 3+1
(11-1)/3=3,1: 3+1
(12-1)/3=3,2: 3+1

提示：

1 <= flowerbed.length <= 2 * 104
flowerbed[i] 为 0 或 1
flowerbed 中不存在相邻的两朵花
0 <= n <= flowerbed.length

'''
from typing import List


# 求最多还能放多少
def canPlaceFlowers(flowerbed: List[int], n: int) -> bool:
    count, m, prev = 0, len(flowerbed), -1
    for i in range(m):
        if flowerbed[i] == 1:
            if prev < 0:
                # 开头的时候能放多少朵
                count += i // 2
            else:
                # 中间能放多少朵
                count += (i - prev - 2) // 2
            prev = i

    if prev < 0:
        # 全是0的时候能放多少的朵
        count += (m + 1) // 2
    else:
        # 结尾的0还能放多少朵
        count += (m - prev - 1) // 2

    return count >= n


if __name__ == '__main__':
    f = [1, 0, 0, 0, 1]
    n = 1
    print(canPlaceFlowers(f, n))
