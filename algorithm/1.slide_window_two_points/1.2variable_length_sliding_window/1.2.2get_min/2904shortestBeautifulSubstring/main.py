'''
2904 最短且字典序最小的美丽子字符串


给你一个二进制字符串 s 和一个正整数 k 。

如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。

令 len 等于 最短 美丽子字符串的长度。

返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。

对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。

例如，"abcd" 的字典序大于 "abcc" ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c 。
 

示例 1：

输入：s = "100011001", k = 3
输出："11001"
解释：示例中共有 7 个美丽子字符串：
1. 子字符串 "100011001" 。
2. 子字符串 "100011001" 。
3. 子字符串 "100011001" 。
4. 子字符串 "100011001" 。
5. 子字符串 "100011001" 。
6. 子字符串 "100011001" 。
7. 子字符串 "100011001" 。
最短美丽子字符串的长度是 5 。
长度为 5 且字典序最小的美丽子字符串是子字符串 "11001" 。
示例 2：

输入：s = "1011", k = 2
输出："11"
解释：示例中共有 3 个美丽子字符串：
1. 子字符串 "1011" 。
2. 子字符串 "1011" 。
3. 子字符串 "1011" 。
最短美丽子字符串的长度是 2 。
长度为 2 且字典序最小的美丽子字符串是子字符串 "11" 。 
示例 3：

输入：s = "000", k = 1
输出：""
解释：示例中不存在美丽子字符串。
 

提示：

1 <= s.length <= 100
1 <= k <= s.length

思考：
此题目需要用到滑动窗口，滑动窗口的长度是不固定的，所以需要用到双指针，一个指向窗口的左边界，一个指向窗口的右边界。
求最小，使用滑动窗口的时候，每次固定right，然后求出当前right下的最小美丽子字符串，然后再求出全局最小的美丽子字符串。
'''



def shortestBeautifulSubstring(s: str, k: int) -> str:
    left = 0
    ans = s
    min_len = float("inf")
    count = 0
    if s.count('1') < k:
        return ""
    for right in range(len(s)):
        if s[right] == "1":
            count += 1
        while left < len(s) and (s[left] == "0" or count > k):
            if s[left] == "1":
                count -= 1
            left += 1
        if count == k:
            t = s[left:right+1]
            if len(t) < min_len or len(t) == min_len and t < ans:
                min_len = len(t)
                ans = t
    return ans

# s = "100011001"
# k = 3
# print(shortestBeautifulSubstring(s, k)) # 11001
s = "10100010"
k = 5
print(shortestBeautifulSubstring(s, k)) # ""

        